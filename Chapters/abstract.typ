#import "../Packages/global.typ": *

#let abstract = {
[
Using graphics processing units (GPUs) for computations bring a significant amount of computational power compared to the central processing unit (CPU) through the use parallelisation. The functional array programming language #fut makes use of array operations known as second-order array combinators (SOACs) for compiling to optimised GPU code.
In this report we extend an existing untyped core language, #butf (a subset of Futhark), and an extended $pi$-calculus with broadcasting capabilities, #epi, by #cn(<ButfToEpi>), with simple type systems (called #btf and #tepi, respectively). The two type systems are then proven to be sound in regards to their respective semantics. The original translation from #butf to #epi is then extended by incorporating the type systems which provides static guarantees about program behaviors.
This results in a type-preserving data-parallel implementation of #btf in #tepi which is proven to be correct through proofs about the translation of the types and behaviour. 
// This then provides a basis for extending the type system with Futhark features such as uniqueness and sized types.
]
}

// This paper presents a formal foundation for compiling a typed subset of the Futhark functional array programming language to a process calculus. We extend an existing untyped core language, ButF (a subset of Futhark), and an extended π-calculus with broadcasting capabilities, Eπ, with simple type systems – resulting in the languages BtF and TEπ, respectively. The BtF type system incorporates base types, arrays, and tuples inspired by Futhark, while the TEπ system introduces location types, pre-channel types, and a composite name environment to manage name reuse during translation. We prove type soundness for both BtF (Theorem 3.1) and TEπ (Theorem 3.2), demonstrating that reductions preserve well-typedness. Building on this, we define a novel type-directed translation from BtF to TEπ, leveraging the type systems to relax constraints present in the original untyped translation. We establish type correctness (Theorem 4.1), guaranteeing that translating a well-typed BtF expression yields a well-typed TEπ process whose output channel type matches the translated BtF type. Furthermore, we prove behavioural correctness (Theorem 4.2), establishing an operational correspondence between source expressions and their translations. These results collectively ensure a faithful, type-preserving data-parallel implementation of BtF in TEπ (Corollary 4.1), providing a basis for extending the type system with Futhark features like uniqueness and sized types.